/* tslint:disable */
/* eslint-disable */

/* auto-generated by NAPI-RS */

export interface MapHexOptions {
  index: number
  x: number
  y: number
  passability: number
  battleground: boolean
  securityIndex: string
}
export const enum SecurityIndexType {
  NoBattles = 0,
  Safe = 1,
  NotSafe = 2,
  FreePvP = 3
}
export interface HexBase {
  x: number
  y: number
  passability: number
  battleground?: string
  securityIndex?: string
}
export interface Point {
  x: number
  y: number
}
export interface GridBorder {
  minX: number
  maxX: number
  minY: number
  maxY: number
}
export interface Hex {
  id: number
  x: number
  y: number
  passable: boolean
  passability: number
  battleground: boolean
  securityIndex: string
}
export declare class HexGrid {
  static new(gridBorder: GridBorder, hexes: Array<HexBase>): HexGrid
  get hexes(): string
  get getwidth(): number
  get height(): number
  isInsideRadius(center: Point, target: Point, radius: number): boolean
  calculateDistanceBetweenHexes(pointA: Point, pointB: Point): number
  findHexByPosition(x: number, y: number): Hex | null
  getNeighboursById(hexId: number): Array<Hex>
  isHexOnBorderOfImpasableArea(point: Point): boolean
  getHexesWithinRange(center: Point, range: number): Array<Hex>
  getBorderPassableNeighbors(point: Point): Array<Hex>
  getDifferenceBetweenAreasWithNeigborCenters(oldCenter: Point, newCenter: Point, range: number): Record<number, Hex>[]
  buildPathToImpassableBorderHex(startId: number, targetId: number): Array<Point>
  buildPathTowardsImpassableHex(startId: number, targetId: number): Array<Point>
  buildPathToPassableHex(startId: number, targetId: number): Array<Point>
}
